#![allow(dead_code)]

use clap::{Args, Parser, Subcommand};

mod decoder;

/// Prints the first 10 numbers (1 to 10)
const CODE: &str = "#epyt-gnirts,0dleif,epyt-erudecorp,epyt-lobmys,epyt-rotcev,x,1dleif,epyt-riap,gnirts>-lobmys,esolc,?bir,*,!tes-1dleif,2dleif,?llun,?rotcev,?erudecorp,gnirts>-rebmun,tneitouq,tsil>-rotcev,?lobmys,-,gnirts>-tsil,?gnirts,ton,snoc,htgnel,pool,2gra,tsil-etirw,tsil>-gnirts,xua-gnirts>-rebmun,<,rac,etirw,2rahctup,+,yalpsid,?ecnatsni,?riap,di,?vqe,srahc-etirw,rdc,rahctup,1gra,,,,bir;89k!9,i$89Gl^>?u>FiO!OGliO~Ku^z!Ok!1(_>?^{!*,i$*a@_>?^*a@_>?^>?vS#~OBvS#_*a@_>?^*a@_>?^>?vS#~O^~^BvE^*a@_>?vS;>?vS#~Bt^*a@_>?vS9>?vS#~Bv0^*a@_>?vS5>?vS#~Bu^*a@_>?^~S`J^~D^{!7,i$,i$87@^>IJ^~D^>?vC~D^z!//YC^1vS7vF~YD^2YA^>?vF~YE^*i$M^~T^/YL^~W^(vL>N@^>IJ^>?vK~D^1vLvK~YF^1vS;vF~Bi%^1vS-vF~S^z!2/^(vE>Ai%M^>?vE~T^z!DEl!Aj%!EEo!6j%!>#nQ_^z!=En!5,^5_`~KakRb^GVYIu``vR%YBu^{!C8>Li&^8>RLi&V`kvP~Kk^z>YHki#!LiN!@Em!:,k0Q@_l~D^z!F+i&^z!)iN!3j%!;#k`^{!-Ek!<+i$^z!.8K,i$+bYG^~YJ^zz!Po]&n]#m]$l!Mk!(:lkl!B:lkm!I:lkn!?:lko!0:lkp!4:lkq!+:lkr!H:lks!G:lkt!N:lku]%:lkv.!J:lkv/!K:lkv0!8:lkv1!':lkv2!,:lkv3y";

fn sym_table() {}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Decode the RIBN generated by the Ribbit Compiler
    Decode(DecodeArgs),
}

#[derive(Args, Debug)]
struct DecodeArgs {
    #[arg(short, long)]
    name: String,

    #[arg(short, long)]
    /// Include the symbol table in the decoded output
    sym_table: bool,
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

/// Extract the symbol table
///
fn main() {
    let cli = Cli::parse();

    match &cli.command {
        Commands::Decode(DecodeArgs { name, .. }) => {
            println!("Decoded {:#?}", name);
        }
    }
}
